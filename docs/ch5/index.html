<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/p5-fes-i18n-book/css/tufte_mod.css">
    <link rel="stylesheet" href="/css/tufte_mod.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Amiri&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Halant:wght@300&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Neuton:wght@200&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Gothic+A1:wght@300;500;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Black+Han+Sans:400" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@200;400;&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&display=swap" rel="stylesheet">
    <title>기계번역/ 사이를 맴도는.</title>
  </head>
  <body>
    <div class="topbar">
  <div class="breadcrumb">
    <p><a href="../">Friendly Errors i18n Book</a> > chapter 5 </p>
  </div>
  <div class="topleft-menu">
    <p> <a href="../en/ch5">ENGLISH</a> </p>
    <p> <a href="../about/">the team</a> </p>
  </div>
</div>
<article>
  <div class="bubble-title">
    <picture>
      <source srcset="../css/bubble-top-dark.svg" media="(prefers-color-scheme: dark)">
      <img src="../css/bubble-top.svg">
    </picture>
    <h1>기계번역/ 사이를 맴도는.</h1>
    <picture>
      <source srcset="../css/bubble-bottom-dark.svg" media="(prefers-color-scheme: dark)">
      <img src="../css/bubble-bottom.svg">
    </picture>
    <p class="subtitle">정앎</p>
  </div>
  <img class="break">
  <div class="toc">
    <p class="toc_title">목차</p>
      <ul class="toc_list">
        <li><a href="#in_between">1. 사이에 놓인 메시지</a></li>
        <li><a href="#generatable">2. 기계가 만들 수 있는 메시지</a></li>
        <li><a href="#searchable">3. 검색가능한 메시지</a></li>
        <li><a href="#symbiosis">4. 번역툴과 공생하는 메시지</a></li>
        <li><a href="#new_opportunity">5. 새로운 협업 기회를 위한 번역</a></li>
      </ul>
  </div>

  <section>
    <picture>
      <source srcset="../css/friendly-bar2-dark.svg" media="(prefers-color-scheme: dark)">
      <img class="break" src="../css/friendly-bar2.svg">
    </picture>
  </section>

  <section>
    <p>
      이 곳에서는 번역의 “다리” 역할을 통해 저희 에러 메시지 세계화 작업이 어떻게 더 거대한 협업 인프라를 엮는데 기여할 수 있을지 생각해보려고 합니다.</p>
    <p>
      번역이란 넓은 뜻으로 “어떤 것을 한 곳에서 다른 곳으로 옮긴다<label for="sn-translation" class="margin-toggle sidenote-number">&#8853;</label><input type="checkbox" id="sn-translation" class="margin-toggle"/><span class="sidenote">Barbara Cassin의 <i>More Than One Language</i> 에서 나온 표현을 인용</span>”는 뜻으로 쓰입니다. 한 언어의 글을 다른 언어로 옮길 때 어떤 일들이 일어날까요? 서로 다른 언어권에 속한 사용자, 더 나아가 서로 다른 문화권에 속한 구성원들의 교류가 시작된다고 볼 수 있습니다. 때문에 번역을 흔히  두 언어문화권 사이 “다리를 놓는 작업”이라 부르기도 하죠.</p>
    <p>
      그러면 영문 에러메시지를 한국어로 번역하는 작업 또한 영어 문화권(기술이 개발되는 곳)과 한국어 문화권(기술을 흡수하는 곳) 간의 투과성을 높히는 작업으로 볼 수 있을까요? 이 질문을 곁에 두고, 번역의 대상인 에러메시지의 주요 목적을 다시 한번 들여다 봅시다.</p>
    <p>
      에러메시지는 디버깅(debugging) 과정<label for="sn-debugging" class="margin-toggle sidenote-number">&#8853;</label><input type="checkbox" id="sn-debugging" class="margin-toggle"/><span class="sidenote">디버깅 (debugging)은 소프트웨어 개발 과정 중 발생하는 오류들을 발견하는 과정을 말합니다. 이는 디버거(debugger)나 인터프레터(interpreter)와 같은 해석프로그램과 그를 보조하는 다른 툴(FES도 여기에 속합니다)의 도움을 통해 진행됩니다. </span> 즉 소프트웨어가 주어진 인풋 코드를 실행하는 도중 에러와 마주쳤을때 만들어내는 메시지입니다. 다시 말해 에러메시지는 기계 속에서 일어나는, 눈에 보이지 않는 추상적 (하지만 동시에 물리적이기도한) 현상을 우리가 읽을 수 있는 형태로 출력한 메시지이죠.</p>
    <p>
      에러메시지가 우리 입력에 반응해 기계가 즉석 제작<label for="sn-impromptu" class="margin-toggle sidenote-number">&#8853;</label><input type="checkbox" id="sn-impromptu" class="margin-toggle"/><span class="sidenote">현재 FES의 메시지는 즉흥적으로 만들어지고 있지는 않습니다만, 앞으로 차세대 인공지능 기술이 적용되기 시작한다면 이런 즉흥성은 더 강해질거라 생각합니다. </span>하는 출력물이라면, 여기서 일어나는 언어 소통 형태는 예컨데, 기존 통역 과정의 형태와 어떻게 다른 것일까요? 이 질문을 떠올리며 이제부터, "인간-기계" 거대 협력망 내 매개체로서 에러메시지의 위치를 살펴보도록 하겠습니다.</p>
  </section>
  <section>
    <h2 id="in_between">사이에 놓인 메시지</h2>
    <p>
      앞에서 이야기했듯 번역 작업은 단절되어 있던 두 집단, 혹은 시스템이 소통할 수 있도록 이어 줍니다. 그러면 우리는 에러메시지 번역으로 누구와 누구를 이어주고 있는 것일까요?
    </p>
    <p>
      우선 “협업을 위한 번역”은, 자신의 언어권 바깥 사람들과 소통하며 같이 일하기 위해 반드시 필요한 선행 작업입니다. 대부분의 새로운 정보가 영어로 작성 및 교류되는 현대 기술 산업 형태를 생각해보면, 영어권 외부의 사람들은 번역이 일어나기 전까지 새로운 정보에 닿을 수 없으므로 새로이 열린 영역에 곧장 진입할 수 없습니다. 여기서 번역은 끊어진 두 영역 사이의 다리 역할을 어느 정도 수행하긴 합니다. 하지만 이는 정보의 생산자인 영어권에서 정보의 수용자인 비영어권으로 흐르는 일방 소통이기도 합니다. <label for="sn-links" class="margin-toggle sidenote-number">&#8853;</label><input type="checkbox" id="sn-links" class="margin-toggle"/><span class="sidenote">이 작업에서 발생하는 문화적 그리고 실무적 이슈들에 대해서는 앞의 [<a href="../ch3">3. 기술 용어 다루기</a>]와 [<a href="../ch4">4. 번역가 간의 약속</a>] 소주제들에서 자세히 다루었으니 참고하면 좋겠습니다.</span>
    </p>
    <p>
      처음 질문으로 돌아가 보죠. 현대 인간-기계 융합적 노동 형태와 산업구조 속에서 누군가와 협업한다는 개념은 인간 협력자에서 벗어나 로봇, 크라우드, 소프트웨어, 그리고 시스템 레벨까지 확장할 수 있습니다. 이제는 한 명의 전문 기술자가 처음부터 끝까지 혼자 시스템을 쌓아올리는 게 아니라, 다른 기술자들은 물론이고 각종 기계 및 시스템들이 제공하는 정보까지 모두 엮어 그 “중간”에서 작업하는 형태가 흔해졌지요. 앞에서 이야기한 디버깅 과정에서 쓰이는 에러메시지 또한 이 인간-기계 협업 형태 내에서 작동하고 있습니다. 이런 맥락 속에서 에러메시지 디자인 및 번역 과정에 어떤 점들을 구체적으로 고려해야 할지 함께 생각해봅시다.
    </p>
  <section>
    <h2 id="generatable">기계가 만들 수 있는 메시지</h2>
    <p>
      디버깅 과정이란 (인간인)프로그래머가 초안으로 쓴 코드를 컴퓨터가 읽어서 문제 없이 수행할 수 있는 코드로 다듬어 가는 과정입니다. 이런 디버깅 과정 내에서 기계가 자신 내부에서 일어난 문제점을 알려오는 에러메시지는 사용자와 컴퓨터 사이 되먹임 구조<label for="sn-feedback" class="margin-toggle sidenote-number">&#8853;</label><input type="checkbox" id="sn-feedback" class="margin-toggle"/><span class="sidenote">되먹임 구조, 피드백(feedback)은 어떤 시스템이 제공된 입력에 대한 출력을 반환하면서 시작됩니다. 이 출력된 내용을 새로운 입력으로 다시 넣으면서 프로세스를 재시작해, 피드백 루프의 완전 순환적인 형태를 완성합니다. 이 경우에는, 사용자가 컴퓨터에 코드를 입력하면, 컴퓨터가 코드를 실행하면서 에러를 찾아 에러 메시지를 출력하고, 여기에 사용자가 수정한 코드를 새로 입력해 계속 루프가 돌아가는 모습을 가리키고 있습니다. </span>를 이어주는 역할을 맡고 있습니다. 이 에러메시지는 결국 컴퓨터가 실시간으로 코드를 실행해 만들어내는 것이기에 대부분 프로그래밍 환경 속에서 무리없이 출력해낼 수 있는 방법으로 작성되어야 하겠습니다. 아무리 기발한 문장, 기술, 혹은 디자인이라고 해도 연산력을 많이 쓰게 하는 (그리고 결국 디버깅 시간을 늘려버리는) 메세지 작성법은 오히려 디버깅 작업을 더 버거운 시간으로 만들어 버리겠지요.
    </p>
    <p>
      현재 FES의 경우 에러메시지를 여러 언어로 구현하기 위해 널리 쓰이는 오픈 소스<label for="sn-opensource" class="margin-toggle sidenote-number">&#8853;</label><input type="checkbox" id="sn-opensource" class="margin-toggle"/><span class="sidenote">오픈 소스(open-source)란 원본 코드가 공개되어 주로 웹을 통해 자유롭게 수정하고 재배포할 수 있는 소프트웨어를 뜻합니다.</span> 세계화<label for="sn-i18n" class="margin-toggle sidenote-number">&#8853;</label><input type="checkbox" id="sn-i18n" class="margin-toggle"/><span class="sidenote"> 특히 IT 산업내에서 한 언어로 쓰여진 콘텐츠를 다른 언어로 제공하는 과정을 세계화(internationalization), 줄여서 i18n라고 표현하고 있습니다. 때로는 국제화로 번역되기도 하며, 여러 상황에서 다른 식으로 사용되기도 해서 이런 표현들이 확립되었다고 보기는 어렵습니다. </span> 툴 중 하나인 [i18next]를 쓰고 있습니다. i18next은 크게 고립어<label for="sn-isolatinglang" class="margin-toggle sidenote-number">&#8853;</label><input type="checkbox" id="sn-isolatinglang" class="margin-toggle"/><span class="sidenote">“형태소가 곧 단어인 고립어”라는 맥락에서 이렇게 표현했습니다. https://ko.wikipedia.org/wiki/%EA%B3%A0%EB%A6%BD%EC%96%B4_(%EC%96%B8%EC%96%B4%EC%9C%A0%ED%98%95%EB%A1%A0)</span>로 볼 수 있는 현대 영어에 기초해 만들어졌고, 문장 속에서 상황에 따라 바뀔 수 있는 부분을 효율적으로 처리하기 위해 인터폴레이션([interpolation])을<label for="sn-interpolation" class="margin-toggle sidenote-number">&#8853;</label><input type="checkbox" id="sn-interpolation" class="margin-toggle"/><span class="sidenote">수치해석학에서 인터폴레이션(interpolation)은 데이터가 없는 부분을 데이터가 존재하는 부분을 참조해 수학적으로 유추해내는 방법으로 보간법(補間法), 혹은 내삽(內揷)이라 번역되기도 합니다. 두 표현 모두 한국어에서 흔히 쓰이는 단어가 아니므로 여기서는 음차번역을 사용해봤습니다.</span> 구현해 놓았는데요, 인터폴레이션은 다르게 말하면 “빈칸 채워 문장 만들기"입니다. 틀이 되는 문장을 미리 써두고 주요 단어의 위치를 비워둔 후, 에러가 발생하면 빈칸에 해당 정보를 채워넣는 방식이지요.
    </p>
    <p>
      이렇게 문장을 레고처럼 조각으로 나누고 다시 이어붙이는 것은 기계가 손쉽게 해내는 작업 중 하나입니다. 하지만 기계가 이 과정에 몰입해 정보를 축약하여 연달아 연결하다 보면 사람에게 어렵거나 어색한 문장 구조가 될 수도 있습니다. 또한 모든 언어가 형태소가 곧 단어인 고립어인 영어와 같은 문법을 구사하고 있지 않다는 점을 꼭 기억해둬야 합니다. 예를 들어 한국어는 중심 형태소에 접두사와 접미사를 비롯한 다른 형태소가 붙어 뜻을 구성하는 교착어<label for="sn-agglutinative" class="margin-toggle sidenote-number">&#8853;</label><input type="checkbox" id="sn-agglutinative" class="margin-toggle"/><span class="sidenote">교착어는 “어근과 접사에 의해 단어의 기능이 결정되는 언어의 형태이다. [...] 단어의 중심이 되는 형태소(어근)에 접두사와 접미사를 비롯한 다른 형태소들이 덧붙어 단어가 구성되는 특징이 있다.” - <a href="https://ko.wikipedia.org/wiki/%EA%B5%90%EC%B0%A9%EC%96%B4"> 위키피디아</a></span>입니다. 이 경우 문장 속 각각 단어를 단독 단위로 단순히 취급하는 데 한계가 있습니다. 전체 문장 구조나 특정 언어의 특성을 무시한 채 무작정 단어만을 바꿔 조립된 메시지는 이해하기 힘들거나, “부자연스럽게” 읽힐 수 있습니다.
    </p>
    <p>
      딥러닝을 비롯한 자연어 합성 기술이 발전하고 있지만, 적은 자원을 써서 쉽고 빠르게 상황에 맞는 문장을 조합해낼 수 있는 외삽법은 에러메시지 구현에 충분히 유용할 거라고 생각됩니다. 우리가 i18next를 사용하는 동안은 외삽법에 맞춘 최선의 메시지를 만들어 내야겠죠. 우리에게 주어진 이런 한계가, 레고 블록을 가지고 놀듯 오류 메시지를 이리저리 재조립해보며, 인간과 기계 모두가 읽기 쉽고, 여러 상황을 담을 수 있게 유연성있으며, 심지어 아름답기까지한 문장을 발견하는 어떤 시적 탐구의 시작점이 될 수 있을까요?
    </p>
  </section>
  <section>
    <h2 id="searchable">검색가능한 메시지</h2>
    <p>
      에러메시지가 작동하는 공간은 컴퓨터–프로그래머 사이에 국한되지 않고 인터넷 검색 공간까지 확장됩니다. 바로 디버깅을 하는 중 누구나 검색을 하기 때문입니다. 여기서 검색 키워드를 찾기 위해 참조하는 게 다름아닌 에러메시지입니다.<label for="sn-searchwords" class="margin-toggle sidenote-number">&#8853;</label><input type="checkbox" id="sn-searchwords" class="margin-toggle"/><span class="sidenote">다음 아티클을 비롯하여 많은 개발자들이 에러메시지를 웹에서 검색해보는 것을 초보자들을 위한 팁으로 권하고 있습니다: <br><code class="sidenote-ref">Spinellis, Diomidis. "Modern debugging: the art of finding a needle in a haystack." Communications of the ACM 61.11 (2018): 124-134.</code></span> 사실 많은 사람들이 에러메시지를 읽기도 전에 통째로 ‘복사-붙여넣기’해 손쉽게 검색을 시도하기도 합니다.
    </p>
    <p>
      이처럼, 에러메시지는 프로그래밍을 하는 사람과 인터넷에 있는 무한한 정보들을 연결하는 역할 또한 수행합니다. 쉬운 언어로만 쓰여진 에러메시지는 언뜻 보면 읽히기 쉽고 사용하기 쉬워 보일지도 모르겠습니다. 반면에 정확한 기술 용어를 쓰지 않는 경우, 검색 엔진이 자연어 처리에 상당히 정교하지 않는 한, 우리가 찾는 결과를 보여줄 가능성이 낮아지겠죠. 쓰인 단어들이 일반적일수록 관련성이 높은 사례를 특정하기 어려우리라 상상해볼 수 있습니다. 쉬운 단어들로만 이뤄진 문장의 문해도 문제는 생각해 보면 인간 독자들에도 적용되는 이야기입니다. 쉬운 단어만을 쓰기 위해 문장 구조가 복잡해지고, 길어지고, 반복이 심해질수록 문장의 의미를 한번에 정확하게 파악하기는 힘들겠지요.
    </p>
    <p>
      그렇다면, 좋은 에러메시지는 특정 문제를 해결하기위해 필요한 정보에 더 빨리 다다를 수 있게하는, 좋은 검색어 또한 제공해야 하지 않을까요? 이러한 메시지는 어떻게 디자인할까요? 다양한 사람들에게 프로그래밍에 대해 폭넓게, 최근의 정보를 제공하고 싶다면 어느 정도는 현대 프로그래밍 작업 과정 맥락 내에서 에러메시지 번역법과 디자인이 정해져야 하지 않을까 합니다.
    </p>
  </section>
  <section>
    <h2 id="symbiosis">번역툴과 공생하는 메시지</h2>
    <p>
      국내 기술 번역 현황조사를 하면서 번역 전문가들도 번역 전문 소프트웨어와 기계 번역을 번역 작업의 도구로써 많이 활용하신다는 것을 알게 되었습니다. 기계 번역 툴은 특히 전문 지식이 담긴 문서들을 초벌 번역할 때 큰 도움이 됩니다. 기계 번역 인공지능 모델을 트레이닝할 때는 이전에 이미 번역되고 표준화되어 출판된 양질의 자료들을 사용하기에, 특히 일대일 대응이 용이한 전문 용어 번역에 높은 정확도를 보이기도 하죠. </p>
    <p>
      전문분야는 점점 더 세분화되고, 새로운 용어들이 매일 생성됩니다. 번역가 한 명이 아무리 매일 전문 분야 지식을 닦아나가고 있다 해도 이를 실시간으로 따라잡기는 물리적으로 힘들 것입니다. 이런 맥락 속에서 기계 툴을 통해 기존 문서들 관행에 맞춰 번역하는 방식이 기술 번역 작업에 큰 도움이 되고 있습니다. 이후 문장을 다듬는 과정이 따르나, 번역자 자신의 기준에 맞춰 작업하기보다는 보통 번역 과정을 의뢰한 고객의 기대치에 맞춰 최단 시간 안에 끝낼수 있게 작업효율성을 극대화하는 방식을 따르게 됩니다. 여기서 쓰이는 기계 번역 툴 또한 이런 방식으로 작성되고 있는 문서들을 참조해 학습된 결과물을 보여주는 되먹임 구조로 트레이닝되고 있다고 볼 수 있습니다. 그렇다면 이 루프에서 발생되는 번역들은 어떤 특징들을 가지게 될까요?</p>
    <p>
      인터넷 상 대다수 정보들이 기계 번역 툴을 이용해 작성되거나 번역되기 시작한다면, 우리 p5js 에러메시지 세계화 논의들은 이 상황 내 어떤 위치에 있고, 어떤 의미가 있는 것일까요? 우리 p5js의 경우에는 어떤 식으로 기계 번역툴을 활용하는 것이 우리가 지향하는 소프트웨어 개발법에 가까울까요? <label for="sn-lim-interview" class="margin-toggle sidenote-number">&#8853;</label><input type="checkbox" id="sn-lim-interview" class="margin-toggle"/><span class="sidenote">이를 생각해보기위해 p5js 웹사이트 세계화를 맡고 계신 Kenneth Lim님의 인터뷰, [오픈 소스 소프트웨어 번역 과정에서 따르는 과제들]이 좋은 시작점이 될 수 있을 것 같습니다.</span> </p>
  </section>
  <section>
    <h2 id="new_opportunity">새로운 협업 기회를 위한 번역</h2>
    <p>
      마지막으로, 번역을 협업의 기회를 만들기 위한 도구로 생각해보는 것에 대해 이야기해 보겠습니다. </p>
    <p>
      이 번역 작업과 논의들은 p5js라는 미국에 거점을 둔 오픈 소스 프로젝트에서 시작되었습니다. p5js에서 세계화 작업이 이야기되기 시작하면서 반가움과 동시에 염려가 되는 점도 많았습니다. 그 중 하나는 여태 글로벌 기업체들이 실행해 온 세계화과정을 답습하는 것에 대해서였죠.</p>
    <p>
      세계화 전략 및 작업은 글로벌 경제권을 구축하기 위해 여러 실리콘 밸리 기업에서 적극 논의 및 추진되고 있습니다. 대부분의 경우 세계화의 첫 단계는 번역입니다. 특히나 비용절감이나 “편리성"을 우선시하는 기계 번역툴을 활용한 세계화에 대한 정보들을 가장 쉽게 만날 수 있습니다. p5js의 세계화 작업의 경우에는 이들과 다른 어떤 우선 사항과 취지를 가질 수 있을지 생각해보는 기회가 있으면 좋겠다는 희망사항이 있었습니다.</p>
    <p>
      그러기에 그 구체적인 작업 방식에서도 차이점이 있으면 좋다고 생각했습니다. 그래서 생각한 것이 새로운 참여 공간을 만들기 위해 번역을 앞으로 내세우는 것이었습니다. 한 곳에서 세계로 툴과 정보를 제공하는 일방 소통 형태에서 벗어나 세계 여러 곳에 거점을 둔 커뮤니티나 개인들이 번역에 참여하고 번역에 대해 논의를 이어가는 공간이 되는 겁니다. 이 공간이 정보, 도구, 아이디어, 그리고 통찰들이 흐르고 맴도는, 어느 방향이든 교류가 이뤄질 수 있는 한  “투과적” 장소가 될 수 있을까요? 앞으로의 p5js의 세계화 작업들이 어떤 방향으로 전개될지 기대가 됩니다.</p>
  </section>
</article>
<div>
  <p class="breadcrumb"> <a href="../">Friendly Errors i18n Book</a> > chapter 5 </p>
</div>
  </body>
</html>